"Regarding the source_address_prefixes suggestion - I don't think consolidating rules makes sense for this module for a few reasons:

Each ESR file is independent with separate opt-in/opt-out controls - ESR-01 through ESR-05 and ESR-08 use enable_enterprise_security_rules, while ESR-06 through ESR-13 have individual enable flags (enable_rubrik_backup, enable_db_admin_access, etc.). Combining rules across ESRs would break this granular control.
This follows the same logic from when you asked about merging all default ESR files into one - I said no because it would create a massive, unmaintainable file. The same principle applies here - keeping rules separate by ESR maintains clarity, modularity, and independent control.
We're replicating AWS Security Groups 1:1 - The AWS rules are structured this way, so Azure should match for easier maintenance and parity.
Rules sharing the same port serve different business purposes - ServiceNow port 22 vs Rubrik port 22 are conceptually different even if they use the same port.

I'm keeping the current structure with source_address_prefix (singular) to maintain the 1:1 mapping from AWS."






"I appreciate the suggestion to flatten directly in the for_each to make the translation more direct. I see the benefit of reducing the intermediate step.
However, I'd like to keep the current locals approach if that's okay because:

Easier debugging and validation - Having the assembled rules in a named local makes it easier to verify which rules are being included during testing and troubleshooting
Cleaner resource block - The main.tf resource definition stays focused on resource creation rather than rule assembly logic
Consistent with the flatten pattern - We're already using flatten in locals for user-defined rules processing, so keeping this pattern consistent makes the codebase more predictable
Separation of concerns - locals.tf handles the 'what rules to include' logic, while main.tf handles the 'how to create them' logic

The current approach works well and I think it'll be easier to maintain as we add features. Does this sound reasonable, or would you prefer I refactor it?"


"Regarding the diagnostic settings - I initially added this to create Log Analytics monitoring for the NSG, but discovered that Azure Policy automatically configures diagnostic settings for NSGs in our environment.
When the module tries to create its own diagnostic setting, it conflicts with the policy-managed one. The policy configuration takes precedence and overrides any module-created settings.
I'm removing this code block entirely since:

Azure Policy already handles NSG diagnostic settings automatically
Users don't need to create their own Log Analytics workspace
This simplifies the module and removes potential conflicts
One less thing for users to configure

The NSG will still have diagnostic settings enabled - just managed by Azure Policy rather than the module."



Done. Split into separate resources: icmp_from_cidrs, tcp_from_cidrs, udp_from_cidrs, tcp_from_asgs, udp_from_asgs, icmp_to_cidrs, tcp_to_cidrs, udp_to_cidrs, tcp_to_asgs, udp_to_asgs.



You're right. Here's the corrected list (40 changes):

1. Rename ESR-01 file to enterprise_security_rules_servicenow.tf
2. Rename ESR-02 file to enterprise_security_rules_solarwinds.tf
3. Rename ESR-03 file to enterprise_security_rules_multi_service_one.tf
4. Rename ESR-04 file to enterprise_security_rules_multi_service_two.tf
5. Rename ESR-05 file to enterprise_security_rules_multi_service_three.tf
6. Rename ESR-06 file to enterprise_security_rules_multi_service_four.tf
7. Rename ESR-07 file to enterprise_security_rules_rubrik_backup.tf
8. Rename ESR-08 file to enterprise_security_rules_database_admin.tf
9. Rename ESR-09 file to enterprise_security_rules_idera_monitoring.tf
10. Rename ESR-10 file to enterprise_security_rules_hsa_monitoring.tf
11. Rename ESR-11 file to enterprise_security_rules_citrix.tf
12. Rename ESR-12 file to enterprise_security_rules_sailpoint.tf
13. Rename ESR-13 file to enterprise_security_rules_varonis_collectors.tf
14. Update rule names from ESR-01/02/etc to service names (ServiceNow, SolarWinds, etc.)
15. Update local variable names to match service names (enterprise_servicenow_rules, etc.)
16. Update locals.tf references to use new local names
17. Rename enable variables from enable_esr_07 to enable_rubrik_backup, etc.
18. Update variables.tf with new enable variable names
19. Update variable descriptions to reference service names
20. Update examples/default to use new variable names
21. Update examples/enterprise_security_rules to use new variable names
22. Update README.md to reference service names instead of ESR numbers
23. Update examples README files with service name references
24. Remove ESR-01 through ESR-13 terminology from all documentation
25. Add detailed "What is this module responsible for?" section to README
26. Add "Notes" section to README (default vs opt-in rules, regional differences)
27. Add "Critical - How to not break things" section to README
28. Add "What is explicitly out of scope?" section to README
29. Split user-defined rules into separate resources (icmp_from_cidrs, tcp_from_cidrs, etc.)
30. Update main.tf with separate resource blocks per protocol/direction
31. Update locals.tf with separate maps for each rule type
32. Remove self_to_self resource (Azure VNet allows this by default)
33. Remove enable_any_nsg_to_self variable
34. Remove self_to_self_rule local
35. Change Allow- prefix to Allow_ for consistent underscore usage
36. Add underscore separator in multi-service names (Allow_MultiService_One_ etc.)
37. Make rule name prefixes unique per file to prevent merge overwrites
38. Update TCP/UDP user rules to use _ranges instead of _range
39. Update enterprise rules to use _ranges for future flexibility
40. Update examples/default with different /32 CIDRs for realistic examples


























# MR Changes Summary

| # | Change |
|---|--------|
| 1 | Rename ESR-01 file to `enterprise_security_rules_servicenow.tf` |
| 2 | Rename ESR-02 file to `enterprise_security_rules_solarwinds.tf` |
| 3 | Rename ESR-03 file to `enterprise_security_rules_multi_service_one.tf` |
| 4 | Rename ESR-04 file to `enterprise_security_rules_multi_service_two.tf` |
| 5 | Rename ESR-05 file to `enterprise_security_rules_multi_service_three.tf` |
| 6 | Rename ESR-06 file to `enterprise_security_rules_multi_service_four.tf` |
| 7 | Rename ESR-07 file to `enterprise_security_rules_rubrik_backup.tf` |
| 8 | Rename ESR-08 file to `enterprise_security_rules_database_admin.tf` |
| 9 | Rename ESR-09 file to `enterprise_security_rules_idera_monitoring.tf` |
| 10 | Rename ESR-10 file to `enterprise_security_rules_hsa_monitoring.tf` |
| 11 | Rename ESR-11 file to `enterprise_security_rules_citrix.tf` |
| 12 | Rename ESR-12 file to `enterprise_security_rules_sailpoint.tf` |
| 13 | Rename ESR-13 file to `enterprise_security_rules_varonis_collectors.tf` |
| 14 | Update rule names from ESR-01/02/etc to service names (ServiceNow, SolarWinds, etc.) |
| 15 | Update local variable names to match service names (`enterprise_servicenow_rules`, etc.) |
| 16 | Update `locals.tf` references to use new local names |
| 17 | Rename enable variables from `enable_esr_07` to `enable_rubrik_backup`, etc. |
| 18 | Update `variables.tf` with new enable variable names |
| 19 | Update variable descriptions to reference service names |
| 20 | Update `examples/default` to use new variable names |
| 21 | Update `examples/enterprise_security_rules` to use new variable names |
| 22 | Update `README.md` to reference service names instead of ESR numbers |
| 23 | Update examples README files with service name references |
| 24 | Remove ESR-01 through ESR-13 terminology from all documentation |
| 25 | Add detailed "What is this module responsible for?" section to README |
| 26 | Add "Notes" section to README (default vs opt-in rules, regional differences) |
| 27 | Add "Critical - How to not break things" section to README |
| 28 | Add "What is explicitly out of scope?" section to README |
| 29 | Split user-defined rules into separate resources (`icmp_from_cidrs`, `tcp_from_cidrs`, etc.) |
| 30 | Update `main.tf` with separate resource blocks per protocol/direction |
| 31 | Update `locals.tf` with separate maps for each rule type |
| 32 | Remove `self_to_self` resource (Azure VNet allows this by default) |
| 33 | Remove `enable_any_nsg_to_self` variable |
| 34 | Remove `self_to_self_rule` local |
| 35 | Change `Allow-` prefix to `Allow_` for consistent underscore usage |
| 36 | Add underscore separator in multi-service names (`Allow_MultiService_One_` etc.) |
| 37 | Make rule name prefixes unique per file to prevent merge overwrites |
| 38 | Update TCP/UDP user rules to use `_ranges` instead of `_range` |
| 39 | Update enterprise rules to use `_ranges` for future flexibility |
| 40 | Update `examples/default` with different /32 CIDRs for realistic examples |


















sed -i 's/source_address_prefixes\s*=\s*\["0-65535"\]/source_address_prefixes = ["*"]/g' enterprise_security_rules_*.tf


sed -i 's/source_port_ranges\s*=\s*\["0-65535"\]/source_port_range = "*"/g' *.tf


sed -i 's/source_port_ranges\s*=\s*\["\*"\]/source_port_range = "*"/g' main.tf



# Enterprise Security Rules NSG Module Usage

## Description

Creates a Network Security Group with all Enterprise Security Rules enabled, including default rules (ServiceNow, SolarWinds, Multi-Service) and opt-in rules (Citrix, Database Admin, HSA Monitoring, Idera Monitoring, Rubrik Backup, SailPoint, Varonis Collectors).


Terraform module to create Azure Network Security Groups with enterprise-managed rules and user-defined rules. It replicates AWS Enterprise Security Group functionality via variables. It tags resources that are created with environment, module_name, module_version, architecture, owner, purpose, terraform_resource, and one of appid|appgid|project.


"Checked - these CIDRs are unique to database_admin and not used in other ESR files. Also, different rules use different subsets of CIDRs (some use 9 IPs, some use 8 IPs, one uses 1 IP). Creating a local would add complexity without much reuse benefit. Happy to discuss if you prefer otherwise."

for_each = var.enable_any_egress ? toset(["enabled"]) : toset([])


Refactored as suggested. CIDR rules now use direct for_each on the variable in the resource block - no intermediate locals processing. ASG rules still use locals for flattening since we need to split multiple ASG IDs into separate rules (Azure requirement).



https://learn.microsoft.com/en-us/cli/azure/network/nsg/rule?view=azure-cli-latest

https://github.com/hashicorp/terraform-provider-azurerm/issues/1346

The Terraform provider documentation shows list(string), but Azure has a backend limitation that only allows 1 ASG per rule. Terraform validate and plan will pass, but apply fails with error: "A security rule may have up to 1 Application Security Group in the source or destination fields."
This is why we need the flattening - to create separate rules for each ASG ID.




A shared local only helps if future CIDR changes will always apply to all rules using it — meaning every port that currently shares the same CIDR list will always get the same CIDR additions, removals, or updates in the future, with no port-specific changes ever.
Since each rule is for a different port, future updates are likely to be port-specific. Creating a shared local now would make those future changes harder.

For example, in database_admin we have:

An exact same list of 9 CIDRs repeated 2 times
An exact same list of 8 CIDRs repeated 2 times
A single CIDR used 1 time
0.0.0.0/0 used 1 time

Yes, we could create local.database_admin_cidrs_9 and local.database_admin_cidrs_8 for the repeated lists. But this adds more lines (local definitions + references) and doesn't reduce complexity.
If in the future they need to add a CIDR to only one of the rules using the shared local:

They can't update the local (the other rule still needs the old value)
They have to remove the local reference from that rule
They have to write the CIDRs inline
Now we have a mix of local references and inline values

This is especially problematic when a local is created for a list that's only repeated 2 times. One different addition and the shared local becomes useless — the code ends up more confusing than if we just kept everything inline from the start.
This is my opinion, but I'm open to going with your approach if you prefer.


That PR didn't fix the limitation — it added MaxItems: 1 validation in the Terraform provider to enforce Azure's backend limit. The Azure limit of 1 ASG per rule still exists. The PR just makes Terraform catch it earlier instead of failing at apply.

1. main.tf - 6 places (CIDR-based rules)
LineCurrentNew53name = "${each.key}-icmp"name = "Allow-ICMP"70name = "${each.key}-tcp"name = "Allow-TCP_${each.key}"87name = "${each.key}-udp"name = "Allow-UDP_${each.key}"138name = "egress-${each.key}-icmp"name = "Allow-Egress-ICMP"155name = "egress-${each.key}-tcp"name = "Allow-Egress-TCP_${each.key}"172name = "egress-${each.key}-udp"name = "Allow-Egress-UDP_${each.key}"

2. locals.tf - 4 places (ASG-based rules)
LineCurrentNew39key = "${port}-tcp-asg-${y}"key = "Allow-TCP_${port}-asg-${y}"54key = "${port}-udp-asg-${y}"key = "Allow-UDP_${port}-asg-${y}"69key = "egress-${port}-tcp-asg-${k}"key = "Allow-Egress-TCP_${port}-asg-${k}"84key = "egress-${port}-udp-asg-${k}"key = "Allow-Egress-UDP_${port}-asg-${k}"




k is the index from iterating over the destination_asg_ids list. Since Azure only allows 1 ASG per rule, we flatten the list and create separate rules for each ASG ID. The index ensures unique rule names when multiple ASGs are provided for the same port.
